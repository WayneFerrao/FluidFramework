/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { existsSync, mkdirSync, rmSync, writeFileSync } from "node:fs";
import path from "node:path";
import { Project, SourceFile } from "ts-morph";
import { typeOnly } from "./compatibility";
import { getTypeRollupPathFromExtractorConfig, checkExportsAndTypes, typeDataFromFile, generateCompatibilityTestCases, prepareAndSkipTestGenerationIfDisabled} from "./typeTestUtils";

const typeRollupPaths = getTypeRollupPathFromExtractorConfig("alpha");

let typeDefinitionFilePath: string;

// Check if a specified typeRollupFile exists
if (typeRollupPaths) {
	typeDefinitionFilePath = typeRollupPaths;
} else {
	typeDefinitionFilePath = checkExportsAndTypes()
}

prepareAndSkipTestGenerationIfDisabled();

const currentFile = new Project({
	skipFileDependencyResolution: true,
	tsConfigFilePath: "tsconfig.json",
}).getSourceFileOrThrow("index.ts");

const previousTsConfigPath = `${previousBasePath}/tsconfig.json`;
let previousFile: SourceFile;
const project = new Project({
	skipFileDependencyResolution: true,
	tsConfigFilePath: existsSync(previousTsConfigPath) ? previousTsConfigPath : undefined,
});
// Check for existence of alpha and add appropriate file
if (existsSync(typeDefinitionFilePath)) {
	project.addSourceFilesAtPaths(typeDefinitionFilePath);
	previousFile = project.getSourceFileOrThrow(`${previousPackageName}-alpha.d.ts`);
	// Fall back to using .d.ts
} else {
	project.addSourceFilesAtPaths(`${previousBasePath}/dist/**/*.d.ts`);
	previousFile = project.getSourceFileOrThrow("index.d.ts");
}

const currentTypeMap = typeDataFromFile(currentFile);
const previousData = [...typeDataFromFile(previousFile).values()];

function compareString(a: string, b: string): number {
	return a > b ? 1 : a < b ? -1 : 0;
}

previousData.sort((a, b) => compareString(a.name, b.name));

const testString: string[] = [
	`/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */
import type * as old from "${previousPackageName}";
import type * as current from "../../index";
`,
	typeOnly,
];

const testCases = generateCompatibilityTestCases(testString, previousData, currentTypeMap);

mkdirSync("./src/test/types", { recursive: true });

writeFileSync(filePath, testCases.join("\n"));
console.log(`generated ${path.resolve(filePath)}`);
