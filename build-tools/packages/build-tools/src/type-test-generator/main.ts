/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { existsSync, mkdirSync, rmSync, writeFileSync } from "node:fs";
import path from "node:path";
import { Project, SourceFile } from "ts-morph";
import { typeOnly } from "./compatibility";
import {getPreviousPackageJsonPath, getTypeRollupPathFromExtractorConfig, checkExportsAndTypes, typeDataFromFile, generateCompatibilityTestCases} from "./typeTestUtils";

const previousPackageJsonPath = getPreviousPackageJsonPath();

if (!existsSync(previousPackageJsonPath)) {
	throw new Error(
		`${previousPackageJsonPath} not found. You may need to install the package via pnpm install. Note that type tests logic looks specifically for a package named '${previousPackageName}'`,
	);
}

const typeRollupPaths = getTypeRollupPathFromExtractorConfig("alpha");

let typeDefinitionFilePath: string;

// Check if a specified typeRollupFile exists
if (typeRollupPaths) {
	typeDefinitionFilePath = typeRollupPaths;
} else {
	typeDefinitionFilePath = checkExportsAndTypes()
}

const testPath = `./src/test/types`;
// remove scope if it exists
const unscopedName = path.basename(packageObject.name);

const fileBaseName = unscopedName
	.split("-")
	.map((p) => p[0].toUpperCase() + p.substring(1))
	.join("");
const filePath = `${testPath}/validate${fileBaseName}Previous.generated.ts`;

if (packageObject.typeValidation?.disabled) {
	console.log("skipping type test generation because they are disabled in package.json");
	// force means to ignore the error if the file does not exist.
	rmSync(filePath, { force: true });
	process.exit(0);
}

{
	// Information about the previous package from the package.json is not needed,
	// but error if its missing since it's nice to separate errors for the dep missing here vs not installed.
	// This block ensures that a critical dependency (the previous package version) is correctly declared in the project's package.json. 
	const previousDep = packageObject?.devDependencies?.[previousPackageName];
	if (typeof previousDep !== "string") {
		throw new Error(`Did not find devDependency ${previousPackageName} in package.json`);
	}
}


if (!existsSync(`${previousBasePath}/package.json`)) {
	throw new Error(
		`${previousBasePath} not found. You may need to install the package via pnpm install.`,
	);
}

const currentFile = new Project({
	skipFileDependencyResolution: true,
	tsConfigFilePath: "tsconfig.json",
}).getSourceFileOrThrow("index.ts");

const previousTsConfigPath = `${previousBasePath}/tsconfig.json`;
let previousFile: SourceFile;
const project = new Project({
	skipFileDependencyResolution: true,
	tsConfigFilePath: existsSync(previousTsConfigPath) ? previousTsConfigPath : undefined,
});
// Check for existence of alpha and add appropriate file
if (existsSync(typeDefinitionFilePath)) {
	project.addSourceFilesAtPaths(typeDefinitionFilePath);
	previousFile = project.getSourceFileOrThrow(`${previousPackageName}-alpha.d.ts`);
	// Fall back to using .d.ts
} else {
	project.addSourceFilesAtPaths(`${previousBasePath}/dist/**/*.d.ts`);
	previousFile = project.getSourceFileOrThrow("index.d.ts");
}

const currentTypeMap = typeDataFromFile(currentFile);
const previousData = [...typeDataFromFile(previousFile).values()];

function compareString(a: string, b: string): number {
	return a > b ? 1 : a < b ? -1 : 0;
}

previousData.sort((a, b) => compareString(a.name, b.name));

const testString: string[] = [
	`/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */
import type * as old from "${previousPackageName}";
import type * as current from "../../index";
`,
	typeOnly,
];

const testCases = generateCompatibilityTestCases(testString, previousData, currentTypeMap);

mkdirSync("./src/test/types", { recursive: true });

writeFileSync(filePath, testCases.join("\n"));
console.log(`generated ${path.resolve(filePath)}`);
