/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
import {
	Dropdown,
	IDropdownOption,
	IDropdownStyles,
	IStackTokens,
	Stack,
	StackItem,
} from "@fluentui/react";
import {
	tokens,
	Combobox,
	ComboboxProps,
	ToggleButton,
	DataGridBody,
	DataGridRow,
	DataGrid,
	DataGridHeader,
	DataGridHeaderCell,
	DataGridCell,
	Dropdown as DropDown,
	DropdownProps,
	Option,
	TableColumnDefinition,
	createTableColumn,
} from "@fluentui/react-components";
import { Info24Regular, Info24Filled } from "@fluentui/react-icons";
import React, { useState } from "react";

import {
	GetTelemetryHistory,
	handleIncomingMessage,
	InboundHandlers,
	ISourcedDevtoolsMessage,
	ITimestampedTelemetryEvent,
	TelemetryHistory,
	TelemetryEvent,
} from "@fluid-tools/client-debugger";
import { useMessageRelay } from "../MessageRelayContext";
import { Waiting } from "./Waiting";

function mapEventCategoryToBackgroundColor(eventCategory: string): string {
	switch (eventCategory) {
		case "generic":
			return tokens.colorPaletteGreenForeground1;
		case "performance":
			return tokens.colorPaletteBlueForeground2;
		case "error":
			return tokens.colorPaletteRedBackground3;
		default:
			return tokens.colorNeutralBackground1;
	}
}

/**
 * Set the default displayed size to 100.
 */
const DEFAULT_PAGE_SIZE = 100;

/**
 * Displays telemetry events generated by FluidFramework in the application.
 */
export function TelemetryView(): React.ReactElement {
	const messageRelay = useMessageRelay();
	const [telemetryEvents, setTelemetryEvents] = React.useState<
		ITimestampedTelemetryEvent[] | undefined
	>();
	const [maxEventsToDisplay, setMaxEventsToDisplay] = React.useState<number>(DEFAULT_PAGE_SIZE);
	const [selectedCategory, setSelectedCategory] = useState("");
	const [filteredTelemetryEvents, setFilteredTelemetryEvents] = React.useState<
		ITimestampedTelemetryEvent[] | undefined
	>();
	const [customSearch, setCustomSearch] = React.useState("");
	const [eventNameOptions, setEventNameOptions] = useState<string[]>([]);
	const [matchingOptions, setMatchingOptions] = React.useState([...eventNameOptions]);

	React.useEffect(() => {
		// Create list of all event names
		setEventNameOptions([
			...new Set(
				telemetryEvents?.map((event) =>
					event.logContent.eventName.slice("fluid:telemetry:".length),
				),
			),
		]);
		// Initialy matching options are all options
		setMatchingOptions(eventNameOptions.sort());
		const filteredEvents = telemetryEvents?.filter((event) => {
			return (
				(selectedCategory === "" ||
					selectedCategory === "All" ||
					event.logContent.category === selectedCategory) &&
				(customSearch === "" ||
					event.logContent.eventName.slice("fluid:telemetry:".length) === customSearch)
			);
		});
		setFilteredTelemetryEvents(filteredEvents);
	}, [telemetryEvents, selectedCategory, customSearch]);

	React.useEffect(() => {
		/**
		 * Handlers for inbound messages related to telemetry.
		 */
		const inboundMessageHandlers: InboundHandlers = {
			[TelemetryEvent.MessageType]: (untypedMessage) => {
				const message = untypedMessage as TelemetryEvent.Message;
				setTelemetryEvents((currentEvents) => [
					message.data.event,
					...(currentEvents ?? []),
				]);
				return true;
			},
			[TelemetryHistory.MessageType]: (untypedMessage) => {
				const message = untypedMessage as TelemetryHistory.Message;
				setTelemetryEvents(message.data.contents);
				return true;
			},
		};

		// Event handler for messages coming from the Message Relay
		function messageHandler(message: Partial<ISourcedDevtoolsMessage>): void {
			handleIncomingMessage(message, inboundMessageHandlers);
		}

		messageRelay.on("message", messageHandler);

		// Request all log history
		messageRelay.postMessage(GetTelemetryHistory.createMessage());

		return (): void => {
			messageRelay.off("message", messageHandler);
		};
	}, [messageRelay, setTelemetryEvents]);

	/**
	 * Interface for each item in the telemetry table.
	 */
	interface Item {
		category: string;
		eventName: string;
		information: string;
	}

	const items: Item[] =
		filteredTelemetryEvents !== undefined
			? filteredTelemetryEvents?.map((message) => {
					return {
						category: message.logContent.category,
						eventName: message.logContent.eventName,
						information: JSON.stringify(message.logContent, undefined, 2),
					};
			  }, [])
			: [];

	const columns: TableColumnDefinition<Item>[] = [
		createTableColumn<Item>({
			columnId: "category",
			renderHeaderCell: () => {
				return (
					<div>
						<h2 style={{ marginBottom: 0 }}>Category</h2>
						<DropDown
							placeholder="Filter Category"
							size="small"
							onOptionSelect={handleCategoryChange}
							style={{ minWidth: "120px" }}
						>
							{getCategories().map((option) => (
								<Option style={{ minWidth: "120px" }} key={option.key}>
									{option.text}
								</Option>
							))}
						</DropDown>
					</div>
				);
			},
			renderCell: (message) => {
				return (
					<div
						style={{
							color: mapEventCategoryToBackgroundColor(message.category),
							fontWeight: 700,
						}}
					>
						{message.category}
					</div>
				);
			},
		}),
		createTableColumn<Item>({
			columnId: "eventName",
			renderHeaderCell: () => {
				return (
					<div>
						<h2 style={{ marginBottom: 0 }}>Event Name</h2>
						<Combobox
							freeform
							size="small"
							placeholder="Select an event"
							onChange={onChange}
							onOptionSelect={handleEventNameSelect}
						>
							{customSearch ? (
								<Option
									key="freeform"
									style={{ overflowWrap: "anywhere" }}
									text={customSearch}
								>
									Search for `{customSearch}`
								</Option>
							) : undefined}
							{matchingOptions.map((option) => (
								<Option
									key={option}
									style={{ fontSize: "12px", overflowWrap: "anywhere" }}
								>
									{option}
								</Option>
							))}
						</Combobox>
					</div>
				);
			},
			renderCell: (message) => {
				return (
					<div>
						{/* Since all events start with "fluid:telemetry:", we trim the start of the name */}
						{message.eventName.slice("fluid:telemetry:".length)}
					</div>
				);
			},
		}),
		createTableColumn<Item>({
			columnId: "information",
			renderHeaderCell: () => {
				return (
					<div>
						<h2>Information</h2>
					</div>
				);
			},
			renderCell: (message) => {
				// eslint-disable-next-line react-hooks/rules-of-hooks
				const [expanded, setExpanded] = useState(false);
				const toggleExpanded = (): void => {
					setExpanded(!expanded);
				};
				return (
					<div>
						<ToggleButton
							checked={expanded}
							icon={expanded ? <Info24Filled /> : <Info24Regular />}
							size="small"
							onClick={toggleExpanded}
						>
							{expanded ? "Hide" : "Show"} Info
						</ToggleButton>
						{expanded && <pre>{message.information}</pre>}
					</div>
				);
			},
		}),
	];

	/**
	 * Gets list of valid categories for displayed telemetry events.
	 * @returns list of option
	 */
	function getCategories(): { key: string; text: string }[] {
		const categories = [
			...new Set(filteredTelemetryEvents?.map((event) => event.logContent.category)),
		];
		const dropdownOptions = categories.map((category) => {
			return {
				key: category,
				text: category,
			};
		});
		dropdownOptions.push({ key: "All", text: "All" });
		return dropdownOptions.sort();
	}

	const handleCategoryChange: DropdownProps["onOptionSelect"] = (event, data) => {
		const category = data.optionText !== undefined ? data.optionText : "";
		setSelectedCategory(category);
	};

	/**
	 * Event handler that updates table to display events matching text in event name filter.
	 */
	const onChange: ComboboxProps["onChange"] = (event) => {
		const value = event.target.value.trim();
		const matches = eventNameOptions.filter((option) =>
			option.toLowerCase().includes(value.toLowerCase()),
		);
		setMatchingOptions(matches);
		if (value.length > 0 && matches.length === 0) {
			setCustomSearch(value);
		} else {
			setCustomSearch("");
		}
	};
	/**
	 * Handler for when user selects an option in event name filter.
	 */
	const handleEventNameSelect: ComboboxProps["onOptionSelect"] = (event, data) => {
		let matchingOption = false;
		if (data.optionText !== undefined) {
			matchingOption = eventNameOptions.includes(data.optionText);
		}
		if (matchingOption) {
			const search = data.optionText !== undefined ? data.optionText : "";
			setCustomSearch(search);
		} else {
			setCustomSearch("");
		}
	};

	const log_view =
		telemetryEvents !== undefined ? (
			<>
				<h3>Telemetry events (newest first):</h3>
				<DataGrid
					items={items}
					columns={columns}
					resizableColumns
					columnSizingOptions={{
						category: {
							minWidth: 120,
							idealWidth: 120,
						},
						eventName: {
							minWidth: 375,
							idealWidth: 375,
						},
						information: {
							minWidth: 250,
							idealWidth: 250,
						},
					}}
				>
					<DataGridHeader>
						<DataGridRow style={{ whiteSpace: "normal" }}>
							{({ renderHeaderCell }): JSX.Element => (
								<DataGridHeaderCell>{renderHeaderCell()}</DataGridHeaderCell>
							)}
						</DataGridRow>
					</DataGridHeader>
					<DataGridBody<Item>>
						{({ item, rowId }): JSX.Element => (
							<DataGridRow<Item> key={rowId}>
								{({ renderCell }): JSX.Element => (
									<DataGridCell>{renderCell(item)}</DataGridCell>
								)}
							</DataGridRow>
						)}
					</DataGridBody>
				</DataGrid>
			</>
		) : (
			<Waiting label={"Waiting for Telemetry events"} />
		);

	return (
		<Stack>
			<StackItem>
				<_ListLengthSelection
					currentLimit={maxEventsToDisplay}
					onChangeSelection={(key): void => setMaxEventsToDisplay(key)}
				/>
			</StackItem>
			<StackItem>{log_view}</StackItem>
		</Stack>
	);
}

/**
 * {@link _ListLengthSelectionProps} input props.
 */
interface _ListLengthSelectionProps {
	/**
	 * The current limit (max number of telemetry events to show).
	 * @defaultValue {@link DEFAULT_PAGE_SIZE}
	 */
	currentLimit: number;

	/**
	 * Called when the selection changes.
	 */
	onChangeSelection(newLimit: number): void;
}

/**
 * A dropdown menu for selecting how many logs to display on the page.
 */
function _ListLengthSelection(props: _ListLengthSelectionProps): React.ReactElement {
	const { currentLimit, onChangeSelection } = props;
	const dropdownStyles: Partial<IDropdownStyles> = {
		dropdown: { width: "300px", zIndex: "1" },
	};

	const stackTokens: IStackTokens = { childrenGap: 20 };

	// Options formatted for the Fluent Dropdown component
	const dropdownOptions: IDropdownOption[] = [
		{ key: 50, text: "50" },
		{ key: 100, text: "100" },
		{ key: 500, text: "500" },
		{ key: 1000, text: "1000" },
	];

	return (
		<Stack tokens={stackTokens}>
			<div className="list-size-options">
				<h3>Max number of telemetry events to display: </h3>
				<Dropdown
					placeholder="Select an option"
					selectedKey={currentLimit}
					options={dropdownOptions}
					styles={dropdownStyles}
					// change the number of logs displayed on the page
					onChange={(event, option): void => onChangeSelection(option?.key as number)}
				/>
			</div>
		</Stack>
	);
}
